<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Schedina ‚Äì Sblocco personalizzato & Verifica (combo support)</title>
<style>
  :root{
    /* Pastelli giocosi */
    --bg:#fffdf8; --ink:#1f2230; --muted:#60657a; --card:#ffffff; --line:#ece6ff;
    --accent:#6c7bff; --accent-2:#ff7db3; --accent-3:#7be3c5; --accent-4:#ffd56c;
    --ok:#1e9e69; --bad:#d9415f; --warn:#b98400;
    --shadow: 0 10px 30px rgba(28,25,68,.08), 0 3px 10px rgba(28,25,68,.06);
    --r:22px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--ink);
    background:
      radial-gradient(1200px 600px at -10% -10%, #ffeef6 0%, transparent 65%),
      radial-gradient(1000px 600px at 110% -10%, #eef6ff 0%, transparent 60%),
      radial-gradient(800px 500px at 50% 120%, #eefff7 0%, transparent 55%),
      var(--bg);
    font:16px/1.45 ui-rounded, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial;
    padding:24px; display:flex; align-items:center; justify-content:center;
  }
  .wrap{width:100%; max-width:1100px; display:grid; gap:18px}
  header{display:flex; align-items:center; justify-content:space-between; gap:12px}
  h1{margin:0; font-size:26px; display:flex; align-items:center; gap:10px}
  h1 .logo{
    width:38px; height:38px; border-radius:12px; display:grid; place-items:center; font-size:20px;
    background: linear-gradient(135deg, var(--accent), var(--accent-2)); color:#fff; box-shadow:var(--shadow);
  }
  .pill{
    background:#fff; border:2px dashed var(--accent); border-radius:999px; padding:8px 12px;
    font-weight:800; font-size:12px; color:var(--accent); display:flex; align-items:center; gap:8px;
  }
  .grid{display:grid; gap:18px}
  @media(min-width:950px){ .grid{grid-template-columns:1.05fr .95fr} }

  .card{
    background:var(--card); border:2px solid var(--line); border-radius:var(--r); padding:18px; box-shadow:var(--shadow); position:relative;
  }
  .card h2{margin:0 0 8px 0; font-size:19px; display:flex; align-items:center; gap:8px}
  .sticker{
    position:absolute; right:-8px; top:-10px; transform:rotate(6deg);
    background:#fff; border:2px dashed var(--accent); color:var(--accent);
    border-radius:12px; padding:6px 10px; font-size:12px; font-weight:900; box-shadow:var(--shadow);
  }
  .muted{color:var(--muted); font-size:13px}
  .tag{font-size:12px; font-weight:700; color:#fff; background:linear-gradient(135deg,var(--accent-3),var(--accent-2)); border-radius:999px; padding:4px 10px}

  label{display:block; font-size:13px; color:var(--muted); margin:10px 0 6px}
  input[type="text"], input[type="password"], input[type="date"], input[type="time"], textarea{
    width:100%; background:#fff; color:var(--ink);
    border:2px solid var(--line); border-radius:14px; padding:12px 14px; outline:none; transition:border-color .2s, box-shadow .2s; font-weight:600;
  }
  input:focus, textarea:focus{ border-color:var(--accent); box-shadow:0 0 0 4px rgba(108,123,255,.12) }
  textarea{min-height:150px; resize:vertical}
  .row{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
  .btn{
    border:0; background:#1f2337; color:#fff; padding:12px 16px; border-radius:14px; cursor:pointer;
    font-weight:800; letter-spacing:.2px; box-shadow:var(--shadow); transform:translateY(0);
    transition:transform .06s ease, filter .2s ease, opacity .2s;
  }
  .btn:hover{filter:brightness(1.04)}
  .btn:active{transform:translateY(1px)}
  .btn.primary{background:linear-gradient(135deg,var(--accent),var(--accent-2))}
  .btn.good{background:linear-gradient(135deg,var(--accent-3),#3ac49b)}
  .btn.warn{background:linear-gradient(135deg,var(--accent-4),#ffae42); color:#3a2d00}
  .btn.ghost{background:#fff; color:var(--ink); border:2px dashed var(--line)}
  .btn:disabled{opacity:.6; cursor:not-allowed}

  .count{font-variant-numeric:tabular-nums; font-weight:900; font-size:28px; letter-spacing:.5px}
  .success{color:var(--ok); font-weight:800}
  .error{color:var(--bad); font-weight:800}
  .warnText{color:var(--warn); font-weight:800}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}

  .pretty-list{list-style:none; padding:0; margin:0}
  .pretty-list li{
    padding:8px 10px; margin:6px 0; background:#fff; border:2px solid var(--line); border-radius:12px; font-weight:700;
    display:flex; align-items:center; gap:10px; justify-content:space-between;
  }
  .left{display:flex; align-items:center; gap:10px}
  .pretty-dot{width:12px; height:12px; border-radius:50%; background:linear-gradient(135deg,var(--accent),var(--accent-2)); box-shadow:0 0 0 3px rgba(108,123,255,.18)}
  .badge{padding:2px 8px; border-radius:999px; font-size:12px; font-weight:800; border:2px dashed var(--line)}
  .badge.win{background:#eaffe9; color:#0b6a3f; border-color:#bdf1c6}
  .badge.lose{background:#ffe9ef; color:#8a1031; border-color:#ffc0d0}
  .hl{background:#fff4b8; border-radius:6px; padding:1px 6px}
  .hl2{background:#ffd8ea; border-radius:6px; padding:1px 6px}
  .small{font-size:12px}
  .sep{height:1px; background:var(--line); margin:12px 0}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1><span class="logo">üé≤</span> Schedina ‚Äì <span style="font-weight:900; background:#fff; border-radius:10px; padding:2px 8px; border:2px dashed var(--line)">Sblocco personalizzato</span></h1>
      <div class="pill" id="statePill">‚ö™ Stato: <b>Inizializzazione‚Ä¶</b></div>
    </header>

    <div class="grid">
      <!-- EDITOR -->
      <section class="card" id="editorCard">
        <div class="sticker">‚úçÔ∏è Editor</div>
        <h2>‚úçÔ∏è Inserisci la schedina <span class="tag">si blocca alla tua data/ora</span></h2>
        <p class="muted">
          Salva con una <b>data/ora di sblocco</b> a tua scelta. Prima di quel momento non potrai vedere n√© modificare.
          Dati cifrati in locale. Supporto a <b>pronostici combinati</b> (es. <span class="mono">X2 + Under 3.5</span>).
        </p>

        <label for="title">Titolo/Etichetta</label>
        <input id="title" type="text" placeholder="Schedina Turno 34 ‚Äì Super combo">

        <label for="content">Contenuto (una riga per voce)</label>
        <textarea id="content" placeholder="Esempi:
Napoli ‚Äì Pisa 1
Parma ‚Äì Torino X2
Ath. Bilbao ‚Äì Girona Over 2.5
Roma ‚Äì Lazio GG
Milan ‚Äì Lecce 1 + Over 2.5
Valencia ‚Äì Oviedo 1X2:1 + U/O 3.5:O"></textarea>

        <div class="row">
          <div style="flex:1; min-width:240px">
            <label for="pass">Passphrase (per cifrare/decifrare)</label>
            <input id="pass" type="password" placeholder="La tua chiave segreta">
          </div>
          <div style="width:180px">
            <label for="tag">Tag</label>
            <input id="tag" type="text" placeholder="Settimana 38">
          </div>
        </div>

        <div class="row">
          <div style="width:180px">
            <label for="unlockDate">Data sblocco</label>
            <input id="unlockDate" type="date">
          </div>
          <div style="width:140px">
            <label for="unlockTime">Ora sblocco</label>
            <input id="unlockTime" type="time" step="60">
          </div>
          <div class="small muted">Zona oraria: <b>Europe/Rome</b></div>
        </div>

        <div class="row" style="margin-top:12px">
          <button class="btn primary" id="saveBtn">üíæ Salva & Blocca fino alla data scelta</button>
          <button class="btn ghost" id="clearBtn" title="Rimuove tutto e sblocca">üóëÔ∏è Pulisci</button>
          <span id="saveMsg" class="muted"></span>
        </div>

        <div id="editorLock" class="muted" style="margin-top:12px; display:none">
          <span class="warnText">Editor bloccato.</span> Torna modificabile <span class="mono" id="lockUntilText">‚Äî</span>.
        </div>
      </section>

      <!-- VIEWER / VERIFICA -->
      <section class="card" id="viewerCard">
        <div class="sticker" style="right:auto; left:-8px; transform:rotate(-6deg)">üîí Visualizza</div>
        <h2>üîí Visualizza & Verifica esito</h2>

        <div class="row" style="justify-content:space-between; align-items:flex-end">
          <div>
            <div class="muted">Stato sblocco</div>
            <div id="unlockState" style="font-weight:900">verifica‚Ä¶</div>
          </div>
          <div class="row" style="gap:10px">
            <div class="count" id="countdown">00:00:00:00</div>
            <div class="muted small">gg : hh : mm : ss</div>
          </div>
        </div>
        <div class="sep"></div>

        <label for="viewPass">Passphrase (necessaria dopo lo sblocco)</label>
        <input id="viewPass" type="password" placeholder="La stessa usata al salvataggio">

        <div class="row" style="margin-top:12px">
          <button class="btn good" id="viewBtn">üîì Mostra schedina</button>
          <button class="btn warn" id="resetWeekBtn" title="Dopo lo sblocco puoi ripartire pulito">üÜï Nuova settimana</button>
          <span id="viewMsg" class="muted"></span>
        </div>

        <div id="result" class="card" style="margin-top:14px; background:#fffdfc; border-style:solid">
          <div class="row" style="justify-content:space-between; gap:8px; flex-wrap:wrap">
            <div><span class="muted">Titolo:</span> <b id="resTitle">‚Äî</b></div>
            <div><span class="muted">Tag:</span> <b id="resTag">‚Äî</b></div>
          </div>

          <div class="sep"></div>

          <!-- PANNELLO RISULTATI -->
          <div id="resultsPanel" style="display:none">
            <p class="muted">
              Inserisci i risultati finali per ogni partita, poi premi <b>Valuta esito</b>.
              Puoi incollare i risultati in blocco (uno per riga, formati tipo <span class="mono">2-1</span>, <span class="mono">1:1</span>).
            </p>
            <div class="row" style="align-items:flex-start">
              <button class="btn good" id="evaluateBtn">‚úÖ Valuta esito</button>
              <div>
                <label for="bulkScores" class="small">Incolla risultati in blocco</label>
                <textarea id="bulkScores" placeholder="2-1
1-1
0-0" style="min-height:80px; width:260px"></textarea>
              </div>
              <button class="btn ghost" id="applyBulkBtn" title="Applica ai campi sotto nell'ordine">üì• Applica in ordine</button>
            </div>

            <ul class="pretty-list" id="linesList">
              <li class="muted" style="font-weight:600">Nessun dato da mostrare.</li>
            </ul>

            <div class="sep"></div>
            <div id="summary" class="muted">‚Äî</div>
          </div>
        </div>

        <p class="muted" style="margin-top:10px">
          Dati salvati localmente (<span class="mono">localStorage</span>) e cifrati (AES-GCM con PBKDF2). Zona oraria: Europe/Rome.
        </p>
      </section>
    </div>
  </div>

<script>
/* ====== Time helpers (Europe/Rome) ====== */
function romeParts(date=new Date()){
  const p = new Intl.DateTimeFormat('en-GB',{
    timeZone:'Europe/Rome', weekday:'short', year:'numeric', month:'2-digit', day:'2-digit',
    hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
  }).formatToParts(date);
  const get=t=>p.find(x=>x.type===t)?.value;
  return {weekday:get('weekday'), year:+get('year'), month:+get('month'), day:+get('day'),
          hour:+get('hour'), minute:+get('minute'), second:+get('second')};
}
function romeISOFromDateTimeInputs(dateStr,timeStr){
  const nowP = romeParts(new Date());
  const [y,m,d] = dateStr ? dateStr.split('-').map(n=>+n) : [nowP.year, nowP.month, nowP.day];
  let hh=21, mm=0;
  if(timeStr){ const [hS, mS] = timeStr.split(':'); hh=+hS; mm=+mS; }
  const baseUTC = Date.UTC(y, m-1, d, 0, 0, 0);
  const iso = new Date(baseUTC + (hh-1)*3600*1000 + mm*60*1000).toISOString(); // ~21:00 Rome ‚âà 20:00 UTC
  return iso;
}
function msUntilISO(iso){
  const tgt = new Date(iso);
  const pr = romeParts(new Date());
  const approxNowUTC = Date.UTC(pr.year, pr.month-1, pr.day, pr.hour-1, pr.minute, pr.second);
  return tgt.getTime() - approxNowUTC;
}
function fmtCountdown(ms){
  if(ms<0) ms=0;
  const s=Math.floor(ms/1000), d=Math.floor(s/86400), h=Math.floor((s%86400)/3600), m=Math.floor((s%3600)/60), sec=s%60;
  const pad=n=>String(n).padStart(2,'0'); return `${pad(d)}:${pad(h)}:${pad(m)}:${pad(sec)}`;
}

/* ====== Storage ====== */
const KEY_DATA='schedina.pkg';    // cifrato
const KEY_META='schedina.meta';   // { lockedUntilISO }
function saveMeta(meta){ localStorage.setItem(KEY_META, JSON.stringify(meta)); }
function loadMeta(){ try{return JSON.parse(localStorage.getItem(KEY_META)||'null')}catch{return null} }
function clearAll(){ localStorage.removeItem(KEY_DATA); localStorage.removeItem(KEY_META); }
function hasSaved(){ return !!localStorage.getItem(KEY_DATA); }

/* ====== Crypto (PBKDF2 + AES-GCM) ====== */
function b64(buf){ return btoa(String.fromCharCode(...new Uint8Array(buf))); }
function fromB64(b){ return Uint8Array.from(atob(b), c=>c.charCodeAt(0)); }
async function deriveKey(pass, salt){
  const enc=new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    {name:'PBKDF2', salt, iterations:120000, hash:'SHA-256'},
    keyMaterial, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']
  );
}
async function encryptJSON(obj, pass){
  const enc=new TextEncoder();
  const iv=crypto.getRandomValues(new Uint8Array(12));
  const salt=crypto.getRandomValues(new Uint8Array(16));
  const key=await deriveKey(pass, salt);
  const data=enc.encode(JSON.stringify(obj));
  const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, data);
  return {v:1, iv:b64(iv), salt:b64(salt), ct:b64(ct)};
}
async function decryptJSON(pkg, pass){
  const iv=fromB64(pkg.iv), salt=fromB64(pkg.salt), ct=fromB64(pkg.ct);
  const key=await deriveKey(pass, salt);
  const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct);
  return JSON.parse(new TextDecoder().decode(pt));
}

/* ====== UI Refs ====== */
const statePill=document.getElementById('statePill');

const editorCard=document.getElementById('editorCard');
const editorLock=document.getElementById('editorLock');
const lockUntilText=document.getElementById('lockUntilText');
const saveBtn=document.getElementById('saveBtn');
const clearBtn=document.getElementById('clearBtn');
const saveMsg=document.getElementById('saveMsg');
const titleEl=document.getElementById('title');
const contentEl=document.getElementById('content');
const passEl=document.getElementById('pass');
const tagEl=document.getElementById('tag');
const unlockDateEl=document.getElementById('unlockDate');
const unlockTimeEl=document.getElementById('unlockTime');

const unlockState=document.getElementById('unlockState');
const countdownEl=document.getElementById('countdown');
const viewPassEl=document.getElementById('viewPass');
const viewBtn=document.getElementById('viewBtn');
const resetWeekBtn=document.getElementById('resetWeekBtn');
const viewMsg=document.getElementById('viewMsg');

const resTitle=document.getElementById('resTitle');
const resTag=document.getElementById('resTag');
const resultsPanel=document.getElementById('resultsPanel');
const linesList=document.getElementById('linesList');
const evaluateBtn=document.getElementById('evaluateBtn');
const bulkScores=document.getElementById('bulkScores');
const applyBulkBtn=document.getElementById('applyBulkBtn');
const summary=document.getElementById('summary');

/* ====== Stato ====== */
function setLockedUI(lockedUntilISO){
  [titleEl, contentEl, passEl, tagEl, unlockDateEl, unlockTimeEl, saveBtn].forEach(el=>el.disabled=true);
  editorLock.style.display='block';
  lockUntilText.textContent=new Intl.DateTimeFormat('it-IT',{timeZone:'Europe/Rome',weekday:'long',year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit'}).format(new Date(lockedUntilISO));
  statePill.innerHTML='üü£ Stato: <b>Bloccato</b>';
}
function setUnlockedUI(){
  [titleEl, contentEl, passEl, tagEl, unlockDateEl, unlockTimeEl, saveBtn].forEach(el=>el.disabled=false);
  editorLock.style.display='none';
  statePill.innerHTML='üü¢ Stato: <b>Sbloccato</b>';
}
function refreshState(){
  const meta=loadMeta();
  if(!meta){ setUnlockedUI(); unlockState.innerHTML='üü° In attesa di salvataggio'; countdownEl.textContent='00:00:00:00'; return; }
  setLockedUI(meta.lockedUntilISO);
}

/* ====== Tick countdown ====== */
function tick(){
  const meta=loadMeta();
  if(!meta){ requestAnimationFrame(()=>setTimeout(tick,600)); return; }
  const remain=msUntilISO(meta.lockedUntilISO);
  countdownEl.textContent=fmtCountdown(remain);
  if(remain<=0){ unlockState.innerHTML='<span class="success">‚úÖ Sbloccato: puoi visualizzare</span>'; }
  else { unlockState.innerHTML='üîí Ancora bloccato fino alla data impostata'; }
  requestAnimationFrame(()=>setTimeout(tick,500));
}

/* ====== Save / Clear ====== */
async function handleSave(){
  saveMsg.textContent='';
  const title=(titleEl.value||'').trim();
  const content=(contentEl.value||'').trim();
  const pass=(passEl.value||'').trim();
  const tag=(tagEl.value||'').trim();
  const dateStr=unlockDateEl.value;
  const timeStr=unlockTimeEl.value || '21:00';

  if(!title || !content || !pass || !dateStr){
    saveMsg.innerHTML='<span class="error">Compila titolo, contenuto, passphrase e data di sblocco.</span>';
    return;
  }
  const lockedUntilISO=romeISOFromDateTimeInputs(dateStr,timeStr);
  if(msUntilISO(lockedUntilISO)<=0){
    saveMsg.innerHTML='<span class="error">La data/ora di sblocco deve essere nel futuro.</span>';
    return;
  }
  try{
    const pkg=await encryptJSON({title, content, tag, savedAt:new Date().toISOString()}, pass);
    localStorage.setItem(KEY_DATA, JSON.stringify(pkg));
    saveMeta({lockedUntilISO});
    setLockedUI(lockedUntilISO);
    saveMsg.innerHTML='<span class="success">üéâ Salvato! Ora √® bloccato fino alla tua data/ora.</span>';
    burst();
  }catch(e){
    console.error(e);
    saveMsg.innerHTML='<span class="error">Errore nel salvataggio.</span>';
  }
}
function handleClear(){
  clearAll(); setUnlockedUI();
  saveMsg.innerHTML='<span class="success">Pulito tutto. Editor sbloccato.</span>';
  resTitle.textContent='‚Äî'; resTag.textContent='‚Äî';
  linesList.innerHTML='<li class="muted" style="font-weight:600">Nessun dato da mostrare.</li>';
  resultsPanel.style.display='none';
  summary.textContent='‚Äî';
  unlockState.innerHTML='üü° In attesa di salvataggio';
  countdownEl.textContent='00:00:00:00';
}
function handleResetWeek(){
  const meta=loadMeta();
  if(!meta){ viewMsg.innerHTML='<span class="error">Non c‚Äô√® nulla da resettare.</span>'; return; }
  if(msUntilISO(meta.lockedUntilISO)>0){
    viewMsg.innerHTML='<span class="error">Puoi azzerare solo dopo lo sblocco.</span>'; return;
  }
  handleClear();
  viewMsg.innerHTML='<span class="success">Settimana azzerata. Puoi inserire una nuova schedina!</span>';
}

/* ====== Parser pronostici (con COMBO) ======
   Supporta (singoli):
   - 1X2: "1", "X", "2" oppure "1X2:1"
   - Doppia chance: "1X", "X2", "12"
   - Over/Under: "Over 2.5", "Under 3.5", "O 2.5", "U 2.5", "U/O 3.5:O"
   - BTTS: "GG", "BTTS", "GOAL"  |  "NG", "NO GOAL"
   COMBO: qualsiasi combinazione separata da " + ", "&", ",", " e "
          es: "X2 + Under 3.5", "1 + U/O 3.5:O", "GG & Over 2.5"
*/
const sepRegex = /\s*[-‚Äì‚Äî]\s*/;
const comboSep = /\s*(?:\+|&|,|\be\b)\s*/i;

function parseLine(raw){
  if(!raw) return null;
  const line = raw.trim().replace(/\s+/g,' ');
  // estrai POTENZIALMENTE le squadre (parte non essenziale per la logica)
  let home='', away='';
  if(sepRegex.test(line)){
    const [lhs, rhs] = line.split(sepRegex);
    // Proviamo a capire squadre togliendo le parti di mercato
    const cleanedL = removeMarkets(lhs);
    const cleanedR = removeMarkets(rhs);
    home = cleanedL.trim();
    away = cleanedR.trim();
  }

  // Estrai mercati (singolo o multipli)
  const markets = extractMarkets(line);
  if(markets.length===0){
    return {home, away, market:{type:'UNKNOWN', raw:line}, rawLine:raw};
  }
  if(markets.length===1){
    return {home, away, market:markets[0], rawLine:raw};
  }
  return {home, away, market:{type:'COMBO', picks:markets}, rawLine:raw};
}

// Rimuove match di mercati dal testo (utile per isolare nomi squadre)
function removeMarkets(text){
  let t = text;
  // 1X2:val
  t = t.replace(/\b1X2\s*:\s*([12X])\b/gi, ' ');
  // DC
  t = t.replace(/\b(1X|X2|12)\b/gi, ' ');
  // 1/X/2 soli (parola singola)
  t = t.replace(/\b([12X])\b/g, ' ');
  // OU vari
  t = t.replace(/\bU\/O\s*([0-9](?:\.[05])?)\s*:\s*(O|U)\b/gi, ' ');
  t = t.replace(/\b([OU])\s*([0-9](?:\.[05])?)\b/gi, ' ');
  t = t.replace(/\b(OVER|UNDER)\s*([0-9](?:\.[05])?)\b/gi, ' ');
  // BTTS
  t = t.replace(/\b(GG|BTTS|GOAL)\b/gi, ' ');
  t = t.replace(/\b(NG|NO\s*GOAL)\b/gi, ' ');
  // separatori combo
  t = t.replace(comboSep, ' ');
  return t;
}

function extractMarkets(text){
  // Spezza su potenziali separatori di combinazione ma NON √® obbligatorio:
  // cerchiamo tutti i mercati sul testo completo, poi de-duplico.
  const parts = text.split(comboSep).map(s=>s.trim()).filter(Boolean);

  const found = [];
  const push = m => { if(m) found.push(m); };

  for(const part of parts){
    const m = extractSingleMarket(part);
    if(m) push(m);
  }

  // Se non ha separatori ma c'erano pi√π mercati in un'unica stringa, prova anche a ‚Äúscannerizzare‚Äù l'intera riga
  if(found.length===0){
    const multi = scanAllMarkets(text);
    multi.forEach(push);
  }

  // Deduplica casi come "GG" e "BTTS" assieme (equivalenti)
  const key = m=>{
    if(m.type==='OU') return `OU-${m.pick}-${m.threshold}`;
    if(m.type==='1X2') return `1X2-${m.pick}`;
    if(m.type==='DC')  return `DC-${m.pick}`;
    if(m.type==='BTTS')return `BTTS-${m.pick}`;
    return 'UNKNOWN';
  };
  const seen = new Set();
  return found.filter(m=>{ const k=key(m); if(seen.has(k)) return false; seen.add(k); return true; });
}

function extractSingleMarket(t){
  const T = t.toUpperCase();

  // 1) 1X2 con valore esplicito: "1X2:1"
  let m = T.match(/\b1X2\s*:\s*([12X])\b/);
  if(m) return {type:'1X2', pick:m[1]};

  // 2) DC
  m = T.match(/\b(1X|X2|12)\b/);
  if(m) return {type:'DC', pick:m[1]};

  // 3) 1/X/2 singolo (evita di catturare se c'√® anche DC nella stessa porzione)
  // Se √® presente una DC in 't', evitiamo 1X2 singolo per non duplicare.
  if(!/\b(1X|X2|12)\b/.test(T)){
    m = T.match(/\b([12X])\b/);
    if(m) return {type:'1X2', pick:m[1]};
  }

  // 4) OU vari
  m = T.match(/\bU\/O\s*([0-9](?:\.[05])?)\s*:\s*(O|U)\b/);
  if(m){ const thr=parseFloat(m[1]); const pick=m[2]==='O'?'OVER':'UNDER'; return {type:'OU', pick, threshold:thr}; }

  m = T.match(/\b([OU])\s*([0-9](?:\.[05])?)\b/);
  if(m){ const thr=parseFloat(m[2]); const pick=m[1]==='O'?'OVER':'UNDER'; return {type:'OU', pick, threshold:thr}; }

  m = T.match(/\b(OVER|UNDER)\s*([0-9](?:\.[05])?)\b/);
  if(m){ const thr=parseFloat(m[2]); const pick=m[1]; return {type:'OU', pick, threshold:thr}; }

  // 5) BTTS
  m = T.match(/\b(GG|BTTS|GOAL)\b/);
  if(m) return {type:'BTTS', pick:'GG'};
  m = T.match(/\b(NG|NO\s*GOAL)\b/);
  if(m) return {type:'BTTS', pick:'NG'};

  return null;
}

// Scanner globale se i separatori non ci sono ma i mercati sono concatenati
function scanAllMarkets(text){
  const T = text.toUpperCase();
  const arr = [];

  // ordine: DC -> 1X2:val -> OU -> BTTS -> 1X2 (singolo)
  let m;
  // DC (tutti)
  const dcRe = /\b(1X|X2|12)\b/g; while((m=dcRe.exec(T))!==null){ arr.push({type:'DC', pick:m[1]}); }
  // 1X2:val
  const x2val = /\b1X2\s*:\s*([12X])\b/g; while((m=x2val.exec(T))!==null){ arr.push({type:'1X2', pick:m[1]}); }
  // U/O thr:O|U
  const uoColon = /\bU\/O\s*([0-9](?:\.[05])?)\s*:\s*(O|U)\b/g;
  while((m=uoColon.exec(T))!==null){ arr.push({type:'OU', pick:(m[2]==='O'?'OVER':'UNDER'), threshold:parseFloat(m[1])}); }
  // O thr / U thr
  const shortOU = /\b([OU])\s*([0-9](?:\.[05])?)\b/g;
  while((m=shortOU.exec(T))!==null){ arr.push({type:'OU', pick:(m[1]==='O'?'OVER':'UNDER'), threshold:parseFloat(m[2])}); }
  // Over thr / Under thr
  const longOU = /\b(OVER|UNDER)\s*([0-9](?:\.[05])?)\b/g;
  while((m=longOU.exec(T))!==null){ arr.push({type:'OU', pick:m[1], threshold:parseFloat(m[2])}); }
  // BTTS GG/NG
  const ggRe = /\b(GG|BTTS|GOAL)\b/g; while((m=ggRe.exec(T))!==null){ arr.push({type:'BTTS', pick:'GG'}); }
  const ngRe = /\b(NG|NO\s*GOAL)\b/g; while((m=ngRe.exec(T))!==null){ arr.push({type:'BTTS', pick:'NG'}); }
  // 1X2 singolo (solo se non presente DC per evitare conflitti)
  if(!/\b(1X|X2|12)\b/.test(T)){
    const single = /\b([12X])\b/g;
    while((m=single.exec(T))!==null){ arr.push({type:'1X2', pick:m[1]}); }
  }
  // deduplica dopo (lo fa extractMarkets)
  return arr;
}

/* ====== Valutazione ====== */
function evaluateSingle(market, homeG, awayG){
  const h = Number(homeG), a = Number(awayG);
  if(!Number.isFinite(h)||!Number.isFinite(a)||h<0||a<0) return {ok:false, reason:'score_invalid'};
  const tot = h+a;

  switch(market.type){
    case '1X2': {
      const res = h>a?'1':(h<a?'2':'X');
      return {ok: res===market.pick};
    }
    case 'DC': {
      const res = h>a?'1':(h<a?'2':'X');
      return {ok: market.pick.includes(res)};
    }
    case 'OU': {
      if(typeof market.threshold!=='number') return {ok:false, reason:'thr'};
      if(market.pick==='OVER') return {ok: tot > market.threshold};
      if(market.pick==='UNDER') return {ok: tot < market.threshold};
      return {ok:false};
    }
    case 'BTTS': {
      const both = (h>0 && a>0);
      return {ok: market.pick==='GG' ? both : !both};
    }
    default: return {ok:false, reason:'unknown_market'};
  }
}

function evaluateMarket(market, h, a){
  if(market.type==='COMBO'){
    // tutte devono essere ok
    const results = market.picks.map(p=>evaluateSingle(p, h, a));
    return { ok: results.every(r=>r.ok), details: results };
  }
  return evaluateSingle(market, h, a);
}

/* ====== UI helper ====== */
function renderMarket(m){
  if(m.type==='1X2') return `1X2: <span class="hl">${m.pick}</span>`;
  if(m.type==='DC')  return `Doppia Chance: <span class="hl">${m.pick}</span>`;
  if(m.type==='OU')  return `<span class="hl2">${m.pick}</span> ${m.threshold}`;
  if(m.type==='BTTS')return (m.pick==='GG'?'Goal (entrambi segnano)':'NoGoal');
  if(m.type==='COMBO')return m.picks.map(renderMarket).join(' <span class="small muted">+</span> ');
  return `<span class="warnText">Pronostico non riconosciuto</span>`;
}

/* ====== Results UI build ====== */
function makeLineRow(idx, item){
  const li=document.createElement('li');
  const left=document.createElement('div'); left.className='left';
  const dot=document.createElement('span'); dot.className='pretty-dot';
  const label=document.createElement('div');
  const teams = (item.home||item.away) ? `${item.home||'‚Äî'} vs ${item.away||'‚Äî'}` : 'Partita';
  const marketTxt = renderMarket(item.market);
  label.innerHTML = `<div><b>${teams}</b></div><div class="small muted">${marketTxt}</div>`;
  left.appendChild(dot); left.appendChild(label);

  const right=document.createElement('div');
  // inputs punteggio
  const hIn=document.createElement('input'); hIn.type='number'; hIn.min='0'; hIn.step='1'; hIn.placeholder='H'; hIn.style.width='64px';
  const sep=document.createElement('span'); sep.className='mono muted'; sep.textContent=' - ';
  const aIn=document.createElement('input'); aIn.type='number'; aIn.min='0'; aIn.step='1'; aIn.placeholder='A'; aIn.style.width='64px';
  const badge=document.createElement('span'); badge.className='badge'; badge.textContent='?'; badge.style.marginLeft='8px';

  right.appendChild(hIn); right.appendChild(sep); right.appendChild(aIn); right.appendChild(badge);

  li.appendChild(left); li.appendChild(right);

  return {li, hIn, aIn, badge};
}

/* ====== View flow ====== */
async function handleView(){
  viewMsg.textContent='';
  const meta=loadMeta();
  if(!meta){ viewMsg.innerHTML='<span class="error">Nessuna schedina salvata.</span>'; return; }
  if(msUntilISO(meta.lockedUntilISO)>0){ viewMsg.innerHTML='<span class="error">Disponibile solo dopo lo sblocco.</span>'; return; }
  const pkgStr=localStorage.getItem(KEY_DATA);
  if(!pkgStr){ viewMsg.innerHTML='<span class="error">Dati mancanti.</span>'; return; }
  const pass=(viewPassEl.value||'').trim();
  if(!pass){ viewMsg.innerHTML='<span class="error">Inserisci la passphrase.</span>'; return; }

  try{
    const data = await decryptJSON(JSON.parse(pkgStr), pass);
    // Header
    resTitle.textContent=data.title||'‚Äî'; resTag.textContent=data.tag||'‚Äî';

    // Parse lines
    const lines=(data.content||'').split('\n').map(s=>s.trim()).filter(Boolean);
    const parsed = lines.map(parseLine);

    // Build list
    linesList.innerHTML='';
    resultRows = []; // reset
    parsed.forEach((item, idx)=>{
      const {li, hIn, aIn, badge} = makeLineRow(idx, item||{market:{type:'UNKNOWN'}});
      linesList.appendChild(li);
      resultRows.push({parsed:item, hIn, aIn, badge});
    });

    resultsPanel.style.display='block';
    viewMsg.innerHTML='<span class="success">Schedina caricata ‚úî</span>';
  }catch(e){
    console.error(e);
    viewMsg.innerHTML='<span class="error">Passphrase errata o dati corrotti.</span>';
  }
}

/* ====== Apply bulk scores ====== */
function applyBulk(){
  const rows = (bulkScores.value||'').split('\n').map(s=>s.trim()).filter(Boolean);
  for(let i=0;i<rows.length && i<resultRows.length;i++){
    const m = rows[i].match(/^(\d+)\s*[-:]\s*(\d+)$/);
    if(m){ resultRows[i].hIn.value=m[1]; resultRows[i].aIn.value=m[2]; }
  }
}

/* ====== Evaluate ====== */
let resultRows=[]; // {parsed, hIn, aIn, badge}
function doEvaluate(){
  if(resultRows.length===0){ summary.textContent='Nessuna riga da valutare.'; return; }
  let wins=0, total=0, unknown=0;

  resultRows.forEach(row=>{
    total++;
    const item=row.parsed;
    const h=row.hIn.value, a=row.aIn.value;
    if(!item || !item.market || item.market.type==='UNKNOWN'){
      row.badge.className='badge lose'; row.badge.textContent='?'; unknown++;
      return;
    }
    const ex = evaluateMarket(item.market, h, a);
    if(ex.ok){ row.badge.className='badge win'; row.badge.textContent='OK'; wins++; }
    else { row.badge.className='badge lose'; row.badge.textContent='KO'; }
  });

  const allOk = (wins===total-unknown) && unknown===0 && total>0;
  summary.innerHTML = allOk
    ? `üèÜ <b>Schedina VINCENTE</b> ‚Äì ${wins}/${total} corretti`
    : `‚ÑπÔ∏è Esito: ${wins}/${total} corretti` + (unknown? ` (‚ö†Ô∏è ${unknown} non riconosciuti)`:'');
}

/* ====== Confetti ====== */
function burst(){
  const emojis=['‚ú®','üéâ','üí•','üéä','üåü']; const n=14;
  for(let i=0;i<n;i++){
    const s=document.createElement('div');
    s.textContent=emojis[Math.floor(Math.random()*emojis.length)];
    s.style.position='fixed';
    s.style.left=(window.innerWidth/2+(Math.random()-0.5)*240)+'px';
    s.style.top=(window.innerHeight/2+(Math.random()-0.5)*80)+'px';
    s.style.fontSize=(18+Math.random()*10)+'px';
    s.style.transform=`rotate(${(Math.random()*40-20)}deg)`; s.style.opacity='1';
    s.style.transition='transform 700ms ease-out, opacity 700ms ease-out';
    document.body.appendChild(s);
    requestAnimationFrame(()=>{
      s.style.transform += ` translate(${(Math.random()-0.5)*160}px, ${60+Math.random()*120}px)`;
      s.style.opacity='0';
    });
    setTimeout(()=>s.remove(),800);
  }
}

/* ====== Init ====== */
function initDefaultsForUnlock(){
  // Default: prossima Domenica 21:00
  const now=new Date();
  const pr=romeParts(now);
  const baseUTC=Date.UTC(pr.year, pr.month-1, pr.day, 0,0,0);
  const wd = new Intl.DateTimeFormat('en-GB',{timeZone:'Europe/Rome',weekday:'short'}).format(new Date(baseUTC));
  const idx={Sun:0,Mon:1,Tue:2,Wed:3,Thu:4,Fri:5,Sat:6}[wd];
  let add=(7-idx)%7; if(add===0) add=7;
  const nextYMD = new Date(baseUTC + add*24*3600*1000);
  const y=nextYMD.getUTCFullYear(), m=String(nextYMD.getUTCMonth()+1).padStart(2,'0'), d=String(nextYMD.getUTCDate()).padStart(2,'0');
  unlockDateEl.value = `${y}-${m}-${d}`;
  unlockTimeEl.value = '21:00';
}
function init(){
  refreshState(); tick();
  saveBtn.addEventListener('click', handleSave);
  clearBtn.addEventListener('click', handleClear);
  viewBtn.addEventListener('click', handleView);
  resetWeekBtn.addEventListener('click', handleResetWeek);
  evaluateBtn.addEventListener('click', doEvaluate);
  applyBulkBtn.addEventListener('click', applyBulk);
  initDefaultsForUnlock();
  if(hasSaved()){ document.title='Schedina ‚Äì bloccata fino allo sblocco'; }
}
init();
</script>
</body>
</html>
